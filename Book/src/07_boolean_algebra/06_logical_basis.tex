% !TeX root = ../../main.tex
\subsection{Логический базис}
\label{subsec:logic-basis}

\textbf{Логический базис} --- набор булевых функций, позволяющий реализовать любую другую булеву функцию. \\
Три наиболее востребованных логических базиса: И, ИЛИ, НЕ; ИЛИ-НЕ; И-НЕ.

\todo{Выбрать более подходящий способ}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{src/07_boolean_algebra/7_7.png}
    \caption{Пример реализации функций И, ИЛИ, НЕ в базисе ``И-НЕ''}
\end{figure}

\begin{table}[H]
    \centering
    \resizebox{\textwidth}{!}{
    \begin{tabular}{|c|c|c|}
        \hline
         \thead{Функция} & \thead{Формула} & \thead{Пример} \\ \hline
         ``НЕ'' & $ \overline{x} = \overline{x \ast 1} = \overline{x \ast x} $ &  \makecell*{\includegraphics{7.5-nand-basis-not}} \\ \hline
         ``ИЛИ'' & $ x_0 + x_1 = \overline{\overline{x_0} \ast \overline{x_1}} $  & \makecell*{\includegraphics{7.5-nand-basis-or}} \\ \hline
         ``И'' & $ x_0 \ast x_1 = \overline{\overline{x_0 \ast x_1}} $ & \makecell*{\includegraphics{7.5-nand-basis-and}} \\ \hline
    \end{tabular}
    }
    \caption{Пример реализации функций И, ИЛИ, НЕ в базисе ``И-НЕ''}
    \label{tab:not-and-basis-examples}
\end{table}

\paragraph{Пример реализации функции ``НЕ'' в базисе ``И-НЕ''}

Формула: $ \overline{x} = \overline{x \ast 1} = \overline{x \ast x} $

\begin{figure}[H]
    \centering
    \includegraphics[width=.9\textwidth]{7.5-nand-basis-not}
\end{figure}

\paragraph{Пример реализации функции ``ИЛИ'' в базисе ``И-НЕ''}

Формула: $ x_0 + x_1 = \overline{\overline{x_0} \ast \overline{x_1}} $

\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{7.5-nand-basis-or}
\end{figure}

\paragraph{Пример реализации функции ``И'' в базисе ``И-НЕ''}

Формула: $ x_0 \ast x_1 = \overline{\overline{x_0 \ast x_1}} $

\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{7.5-nand-basis-and}
\end{figure}

\subsubsection{Формы записи математических выражений}
\label{subsubsec:math-notations}

Форма записи по-другому называется нотацией. ``Арность операции'' означает количество операндов, участвующих в операции. \\
Например: $\sqrt{A}$ (унарная), $A\times B$ (бинарная).

\paragraph{Виды нотаций}
\begin{description}
  \item[1489 г.] --- инфиксная запись $A + B$
  \item[1920 г.] --- префиксная (польская) запись $+AB$
  \item[1957 г.] --- постфиксная (обратная польская) запись $AB+$
\end{description}

\textbf{Стек} --- абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO\footnote{LIFO --- (от англ. last in --- first out, ``последним пришел --- первым вышел'')}.
Чаще всего принцип работы стека сравнивают со стопкой тарелок: чтобы взять вторую сверху, нужно снять верхнюю.

\subsubsection{Префиксная нотация}
\label{subsubec:prefix-notation}

\noindent
\textbf{\emph{Пример:}} \\
Инфиксная нотация: $(A + B + C) - E^{D\times F\times G}$ \\
Префиксная нотация: $-++ABC^{\wedge}E\times\times DFG$

\bigskip\noindent
Рассмотрим, как же происходит запись в префиксной нотации:

\begin{enumerate}
    \item   Исходное выражение: $(A + B + C) - E^{D \times F \times G}$.
            Расставляем порядок выполнения операций, согласно математическим правилам.
    \item   Последним выполняется вычитание, а именно из $(A + B + C)$ вычитается $E^{D \times F \times G}$.
            \textbf{Ставим знак в начало.}
            Получается $-(A + B + C)(E^{D\times F\times G})$.
    \item   Рассмотрим $(A + B + C)$, расставим порядок действий.
            Сначала происходит сложение $A$ и $B$, а потом $A+B$ и $C$.
            Начнем с последнего действия, получается: $+(A+B)C$.
            В $(A+B)$ происходит сложение $A$ и $B$, получаем $(+AB)$.
            Совместим все вместе: $(+(+AB)C)$.
    \item   Рассмотрим $(E^{D\times F\times G})$, происходит возведение в степень.
            А именно $E$ возводится в степень $D\times F\times G$.
            Получается $^{\wedge}E(D\times F\times G)$.
    \item   Рассмотрим $D\times F\times G$, расставляем порядок действий.
            Сначала происходит умножение $D$ и $F$, а потом $D\times F$ и $G$.
            Начнем с последнего действия, получается: $\times(D \times F)G$.
            В $(D \times F)$ происходит умножение $D$ и $F$, получаем $(\times DF)$.
            Совместим все вместе: $(\times(\times DF)G)$.
    \item   Совмещаем все вместе.
            Получается: $-(+(+AB)C)(^{\wedge}E(\times(\times DF)G)$.
            Убираем скобки.
            Получили $-++ABC^{\wedge}E\times\times DFG$.
\end{enumerate}

Существует популярная Lisp\footnote{Lisp --- семейство языков программирования}-разновидность префиксной нотации.
И в ней запись будет выглядеть так: $(-(+ABC)(^{\wedge}E(\times DFG)))$

\paragraph{Особенности префиксной нотации}
\begin{itemize}[noitemsep]
  \item Не требуется скобок, если арность фиксирована.
  \item Запись выражения получается короче, чем инфиксная.
  \item Не требуется знать приоритет операций.
  \item Легко декодировать выражение с помощью стека.
  \item Малоприменима на практике (кроме Lisp).
\end{itemize}

\subsubsection{Постфиксная нотация}
\label{subsubsec:postfix-notation}

\noindent\textbf{\emph{Пример:}} \\
Инфиксная нотация: $(A + B + C) - E^{D\times F\times G}$ \\
Постфиксная нотация: $CAB++EGDF\times\times ^{\wedge}-$

\bigskip\noindent
Рассмотрим, как же происходит запись в постфиксной нотации:
\begin{enumerate}
    \item   Исходное выражение: $(A + B + C) - E^{D\times F\times G}$.
            Расставляем порядок выполнения операций, согласно математическим правилам.
    \item   Последним выполняется вычитание, а именно из $(A + B + C)$ вычитается $E^{D\times F\times G}$.
            \textbf{Ставим знак в конец.}
            Получается $(A + B + C)(E^{D\times F\times G})-$.
    \item   Рассмотрим $(A + B + C)$, расставим порядок действий.
            Сначала происходит сложение $A$ и $B$, а потом $A+B$ и $C$.
            Начнем с последнего действия, получается: $С(A+B)+$.
            В $(A+B)$ происходит сложение $A$ и $B$, получаем $(AB+)$.
            Совместим все вместе: $(C(AB+)+)$.
    \item   Рассмотрим $(E^{D\times F\times G})$, происходит возведение в степень.
            А именно $E$ возводится в степень $D\times F\times G$.
            Получается $E(D\times F\times G)^{\wedge}$.
    \item   Рассмотрим $D\times F\times G$, расставляем порядок действий.
            Сначала происходит умножение $D$ и $F$, а потом $D\times F$ и $G$.
            Начнем с последнего действия, получается: $G(D \times F)\times$.
            В $(D \times F)$ происходит умножение $D$ и $F$, получаем $(DF\times)$.
            Совместим все вместе: $(G(DF\times )\times)$.
    \item   Совмещаем все вместе. Получается: $(C(AB+)+)(E(G(DF\times)\times)^{\wedge})-$.
            Убираем скобки.
            Получили $CAB++EGDF\times\times ^{\wedge}-$.
\end{enumerate}

\paragraph{Особенности постфиксной нотации}
\begin{itemize}[noitemsep]
    \item Не требуется скобок, если арность фиксирована.
    \item Запись выражения получается короче, чем инфиксная.
    \item Не требуется знать приоритет операций.
    \item Легко декодировать выражение с помощью стека.
    \item Успешно применяется в компиляторах, в небольшом количестве языков программирования и некоторых ЭВМ (калькуляторы ``Электроника'' и HP).
\end{itemize}

\paragraph{Алгоритм вычисления для постфиксной нотации}
\begin{enumerate}[noitemsep]
    \item Обработка входного символа
    \begin{itemize}[noitemsep]
        \item   Если на вход подан операнд, он помещается на вершину стека.
        \item   Если на вход подан знак операции, то соответствующая операция выполняется над требуемым количеством значений, извлеченных из стека, взятых в порядке добавления.
                Результат выполненной операции кладется на вершину стека.
    \end{itemize}
    \item Если входной набор символов обработан не полностью, перейти к шагу 1.
    \item После полной обработки входного набора символов результат вычисления выражения лежит на вершине стека.
\end{enumerate}


\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{7.5.3-infix}
    \caption{Вычисления выражения $ab+ac\times +$ (в инфиксной нотации $a+b+a\times c$)}
\end{figure}



Рассмотрим вычисление постфиксной нотации в стеке.
Стек не имеет адресных операций.
В нем есть две операции с переменными: $push$ (положить) и $pop$ (забрать).
Если необходимо положить значение в стек, то он кладется с помощью команды $push$ на вершину стека.
При этом, все другие значения сдвигаются вниз.
Арифметические операции ($add$ --- сложить, $mul$ --- умножить) выполняются с переменными (или переменной --- зависит от арности операции), которые лежат на вершине стека.
