\section{Арифметика в ограниченной разрядной сетке}
\label{sec:limited_arithmetics}

\subsection{Представление отрицательных чисел в ЭВМ}

В электронных вычислительных машинах нет возможности обозначить знак "минус" перед числом. Существует несколько способов решения этой проблемы:

\begin{description}
    \item [Специальный знаковый бит] --- определенный бит означает знак числа.
    \example{1} $+5_{10} = 0101_{2}$, $-5_{10} = 1101_{2}$ \\
    В данном случае, знаковый бит --- старший.

    \item [Фиксированное смещение] --- все числа уменьшены на какое-то определенное число.
    \example{2} $-5_{10} = 0000_{2}$, $-4_{10} = 0001_{2}$, \ldots ,$+10_{10} = 1111_{2}$ \\
    В данном случае, все числа уменьшены на 5.

    \item [Нега-двоичная система счисления] --- основание системы счисления равно $-2$.
    \example{3} $-4_{10} = 1100_{-2}$, $+5_{10} = 0101_{-2}$

    \item [Обратный (инверсный) код] --- инвертируются все биты.
    \example{4} $+5_{10} = 0101_{2}$, $-5_{10} = 1010_{2}$

    \item [Дополнительный код] --- инверсия всех бит плюс единица.
    \example{5} $+5_{10} = 0101_{2}$, $-5_{10} = 1011_{2}$
\end{description}

Некоторые из этих способов были реализованы. В 50-х и 60-х годах широко использовался четвертый способ. И специалисты теории информации разбились на два лагеря: те, кто использовал четвертый способ, и те, кто использовал пятый. Долго не могли примириться и компьютеры существовали и в том и в другом виде. Это привело к тому, что в стандарте языка программирования Си не определено как именно представлять отрицательные числа. Если Вы не будете использовать стандартные конструкции языка (например, $a = b + c$), в которых язык Си сам считает значение из памяти и приведет к нужному отрицательному или положительному виду, а сразу обратитесь к внутреннему представлению памяти - к ячейке по адресу (возьмете значение напрямую из ячейки), то хранящиеся там биты будут различны. Все будет зависеть от того, как работает Ваш компьютер: по четвертому способу или по пятому. Так же при складывании некоторых чисел, интерпретированных в обратном коде, в ограниченной разрядной сетке, возникает ошибка и требуется корректировка результата. Пятый способ не требует корректировки. Поэтому было решено использовать для представления отрицательных чисел в ЭВМ дополнительный код.s

\subsubsection*{Алгоритм перевода двоичного числа в дополнительный код и из дополнительного кода в прямой}
\begin{enumerate}
    \item Инвертировать все биты;
    \item Прибавить единицу;
\end{enumerate}

Отличить, в каком коде представлено число в разрядной сетке - в дополнительном или прямом, можно по старшему значащему биту. Если старший бит равен нулю - число положительное, единице - число отрицательное (например, в числе $1010_{2}$ старший бит равен $1$ - число отрицательное и представлено в дополнительном коде).

\bigskip

\noindent\textbf{\emph{Важно! Нумерация бит в разрядной сетке начинается с нуля и идет справа налево.}}

\example{6}

\task перевести число $1101011011_{2}$ в дополнительный код.

\solution инвертируем биты: $1101011011_{2} \to 0010100100_{2}$;
Прибавляем единицу: $0010100100_{2} + 1_{2} = 0010100101_{2}$;

\answer $0010100101_{2}$

\example{7}

\task представить число $-18_{10}$ в 8-разрядной сетке.

\solution так как у нас число отрицательное, то сначала переведем модуль данного числа в двоичную систему счисления: $|-18_{10}| = 18_{10} = 10010_{2}$;
Теперь представим его в дополнительном коде: $10010_{2} \to 01101_{2} + 1_{2} = 01110_{2}$;
Так как у нас 8-разрядная сетка, то дополним число незначащими нулями: $0000\ 1110_{2}$

\answer $-18_{10} = 0000\ 1110_{2}$

\subsection{Диапазон значений}
Фиксированное значение разрядности хранимого числа определяет диапазон возможных значений, которые можно записать в отведенное количество байт.

Пусть в некотором компьютере переменная А хранится с использованием $k$ бит. Чтобы определить диапазон возможных значений, достаточно найти минимальное и максимальное значения А.

\subsubsection{Беззнаковые числа}
Если мы рассматриваем только неотрицательные числа, то минимальным значением $A$ будет 0. Это соответствует случаю, когда в каждом разряде числа $A$ записан ноль.

Максимально представимым число $A$ будет тогда, когда в каждый разряд записаны единицы. Это число, равное $2^k-1$.
Почему минус 1? Ответить на этот вопрос поможет простой пример: рассмотрим трехразрядное число в десятичной СС. Очевидно, что наибольшее такое число 999. Легко убедится, что число 999 можно получить, если вычесть единицу из минимального 4-разрядного числа ($1000 = 10^3$). Видим, что степень 10 соответствует количеству разрядов, которым будет ограничено представление числа. Аналогичное правило можно вывести и для двоичной СС. Тогда для расчёта диапазона представления целых неотрицательных чисел при наличии $k$-разрядной сетки компьютера можно применять следующую формулу: $A \in [0;2^k-1]$.

\subsubsection{Знаковые числа}
Так как при $k$-разрядном представлении отрицательного числа $A$ в дополнительным коде старший разряд выделяется для хранения знака числа, то непосредственное значение числа А может храниться в $k-1$ разрядах. Поэтому для знаковых чисел при наличии $k$-разрядной сетки компьютера можно применять следующую формулу: $A \in [-2^{k-1};2^{k-1}]$.

\subsection{Флаги состояния процессора}
\label{subsec:flags_registers}

\textbf{Регистр флагов} --- регистр процессора, отражающий текущее состояние процессора.

% Как nirtable только с возможностью расширить на всю страницу (сделать environment как nirtable не вышло)
\begin{xltabular}{\textwidth}{|c|c|C|C|}
    \caption{Регистр флагов Intel x86}\label{tab:flags}\\\hline

    \thead{№\\бита} & \thead{Обозна-\\чение} & \thead{Название} & \thead{Описание}\\\hline
    \endfirsthead

    \multicolumn{4}{r}{\small Продолжение таблицы~\thetable}\\\hline
    \thead{№\\бита} & \thead{Обозна-\\чение} & \thead{Название} & \thead{Описание}\\\hline
    \endhead

    \multicolumn{4}{|c|}{\textbf{FLAGS}} \\ \hline
    0 & CF & Carry Flag & Флаг переноса \\ \hline
    1 & - & - & Зарезервирован \\ \hline
    2 & PF & Parity Flag & Флаг четности \\ \hline
    3 & - & - & Зарезервирован \\ \hline
    4 & AF & Auxiliary Carry Flag & Вспомогательный флаг переноса \\ \hline
    5 & - & - & Зарезервирован \\ \hline
    6 & ZF & Zero Flag & Флаг нуля \\ \hline
    7 & SF & Sign Flag & Флаг знака \\ \hline
    8 & TF & Trap Flag & Флаг трассировки \\ \hline
    9 & IF & Interrupt Enable Flag & Флаг разрешения прерываний  \\ \hline
    10 & DF & Direction Flag & Флаг направления \\ \hline
    11 & OF & Overflow Flag & Флаг переполнения \\ \hline
    12 & \multirow{2}{*}{IOPL} & \multirow{2}{=}{\centering I/O Privilege Level} & \multirow{2}{=}{\centering Уровень приоритета ввода-вывода} \\ \cline{1-1}
    13 & & & \\ \hline
    14 & NT & Nested Task & Флаг вложенности задач \\ \hline
    15 & - & - & Зарезервирован \\ \hline

    \multicolumn{4}{|c|}{\textbf{EFLAGS}} \\ \hline
    16 & RF & Resume Flag & Флаг возобновления \\ \hline
    17 & VM & Virtual-8086 Mode & Режим виртуального процессора 8086 \\ \hline
    18 & AC & Alignment Check & Проверка выравнивания \\ \hline
    19 & VIF & Virtual Interrupt Flag & Виртуальный флаг разрешения прерывания \\ \hline
    20 & VIP & Virtual Interrupt Pending & Ожидающее виртуальное прерывание \\ \hline
    21 & ID & ID Flag & Проверка на доступность инструкции CPUID \\ \hline
    22 -- 31 & - & - & Зарезервированы \\ \hline
    \multicolumn{4}{|c|}{\textbf{RFLAGS}} \\ \hline
    32 -- 63 & - & - & Зарезервированы \\ \hline
    22 & \multirow{3}{*}{-} & \multirow{3}{*}{-} & \multirow{3}{*}{Зарезервированы}  \\ \cline{1-1}
    $\cdots$ & & & \\ \cline{1-1}
    31 & & & \\ \hline

    \multicolumn{4}{|c|}{\textbf{RFLAGS}} \\ \hline
    32 & \multirow{3}{*}{-} & \multirow{3}{*}{-} & \multirow{3}{*}{Зарезервированы} \\ \cline{1-1}
    $\cdots$ & & & \\ \cline{1-1}
    63 & & & \\\hline
\end{xltabular}

После любой арифметической операции процессор автоматически без участия программиста заполняет регистр флагов состояния. Состояние процессора меняется после каждой арифметической операции.

Таблица~\ref{tab:flags} представлена для ознакомления. Для курса <<Информатика>> необходимо знать следующие флаги:

\begin{description}
    \item [CF (Carry Flag) --- Флаг переноса.] Устанавливается (принимает значение $1$) в случае, если происходит перенос за пределы разрядов или заем извне.
    \item [PF (Parity Flag) --- Флаг четности] Устанавливается, если младший значащий байт результата содержит четное число единичных (ненулевых) бит. Изначально этот флаг был ориентирован на использование в коммуникационных программах: при передаче данных по линиям связи для контроля мог также передаваться бит четности.
    \item [AF (Auxiliary Carry Flag) --- Вспомогательный флаг переноса.] Устанавливается, если произошел заем или перенос между первым и вторым полубайтами (третьим и четвертым битами).
    \item [ZF (Zero Flag) --- Флаг нуля.] Устанавливается, если результат машинной операции по модулю 2 в степени $k$ (где $k$ - разрядность ячейки) равен нулю (другими словами, принимает значение $1$, если результат выполнения операции равен нулю).
    \item [SF (Sign Flag) --- Флаг знака.] Устанавливается, если результат выполнения операции отрицателен (равен значению старшего значащего бита).
    \item [OF (Overflow Flag) --- Флаг переполнения.] Устанавливается, если в результате выполнения операции со знаковыми числами появляется одна из ошибок: при сложении положительных чисел получается отрицательный результат или при сложении отрицательных чисел получается положительный результат.
\end{description}

\example{1}

\task сложить $14837_{10}$ и $5832_{10}$ в 16-разрядной сетке. Расставить флаги состояния процессора.

\solution для начала переведем исходные числа в двоичную систему счисления. $14837_{10} = 0011\ 1001\ 1111\ 0101_{2}$, $5832_{10} = 0001\ 0110\ 1100\ 1000_{2}$.
\begin{tabular}{r l c r c | c c |}
\\ \cline{6-7}
\multirow{2}{*}{+} & $0011\ 1001\ 1111\ 0101_{2}$ & = & $14837_{10}$ & & CF = 0 & ZF = 0 \\
& $0001\ 0110\ 1100\ 1000_{2}$ & = & $5832_{10}$ & & PF = 1 & SF = 0 \\ \cline{2-2}
& $0101\ 0000\ 1011\ 1101_{2}$ & = & $20669_{10}$ & & AF = 0 & OF = 0 \\ \cline{6-7}
\end{tabular}

\bigskip

\noindentТак как $0101\ 0000\ 1011\ 1101_{2} = 20669_{10}$, то результат операции сложения в 16-разрядной сетке корректен.

\example{2}

\task сложить $21324_{10}$ и $13543_{10}$ в 16-разрядной сетке. Расставить флаги состояния процессора.

\solution для начала переведем исходные числа в двоичную систему счисления. $21324_{10} = 0101\ 0011\ 0100\ 1100_{2}$, $13543_{10} = 0011\ 0100\ 1110\ 0111_{2}$.
\begin{tabular}{r l c r c | r r |}
\\ \cline{6-7}
\multirow{2}{*}{+} & $0101\ 0011\ 0100\ 1100_{2}$ & = & $21324_{10}$ & & CF = 0 & ZF = 0 \\
& $0011\ 0100\ 1110\ 0111_{2}$ & = & $13543_{10}$ & & PF = 0 & SF = 0 \\ \cline{2-2}
 & $1000\ 1000\ 0011\ 0011_{2}$ & = & $-30669_{10}$ & & AF = 0 & OF = 1 \\ \cline{6-7}
\end{tabular}

\bigskip

\noindentТак как $1000\ 1000\ 0011\ 0011_{2} = -30669_{10} \ne 34867_{10} = 21324_{10} + 13543_{10}$, то результат операции сложения в 16-разрядной сетке некорректен. \\OF = 1: при складывании положительных чисел получили отрицательное.

\example{3}

\task аналогично примерам 1 и 2 - сложить $-7453_{10}$ и $24732_{10}$.

\solution $24732_{10} = 0110\ 0000\ 1001\ 1100_{2}$, $-7453_{10} = 1110\ 0010\ 1110\ 0011_{2}$ ($-7453_{10}$ представляем в дополнительном коде для 16-разрядной сетки).

\begin{tabular}{r l c r c | r r |}
\\ \cline{6-7}
\multirow{2}{*}{+} & $0110\ 0000\ 1001\ 1100_{2}$ & = & $24732_{10}$ & & CF = 1 & ZF = 0 \\
& $1110\ 0010\ 1110\ 0011_{2}$ & = & $-7453_{10}$ & & PF = 0 & SF = 0 \\ \cline{2-2}
$1$& $0100\ 0011\ 0111\ 1111_{2}$ & = & $17279_{10}$ & & AF = 0 & OF = 0 \\ \cline{6-7}
\end{tabular}

\bigskip

\noindentТак как $0100\ 0011\ 0111\ 1111_{2} = 17279_{10}$, то результат операции сложения в 16-разрядной сетке корректен. Несмотря на то, что произошел выход за пределы разрядности сетки.
