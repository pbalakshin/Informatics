% !TeX root = ../../main.tex
\subsection{Классификация архитектур ЭВМ}\label{subsec:evm-classification}

\textbf{Архитектура ЭВМ} --- концептуальная структура вычислительной машины, определяющая проведение обработки информации и включающая методы преобразования информации в данные и принципы взаимодействия технических средств и программного обеспечения.
\textbf{Архитектурой ЭВМ} определяется, как именно в этой ЭВМ происходит обработка и преобразование данных с учетом конкретных принципов взаимодействия технических средств и программного обеспечения.

В 30-х годах правительство США поручило Гарвардскому и Принстонскому университетам разработать архитектуру ЭВМ для военно-морской артиллерии.
Победила разработка Принстонского университета (более известная как архитектура фон Неймана, названная так по имени разработчика, первым предоставившего отчет об архитектуре), так как она была проще в реализации.
Гарвардская архитектура использовалась советским учёным А. И. Китовым.

В настоящее время наибольшее распространение в ЭВМ получили эти 2 типа архитектуры: \emph{принстонская (неймановская)} и \emph{гарвардская}.
Обе они выделяют 2 основных узла ЭВМ: центральный процессор и память компьютера.
Различие заключается в структуре памяти:
\begin{itemize}
    \item \textbf{Принстонская архитектура:} программы и данные хранятся в одном массиве памяти (микросхеме) и передаются в процессор по одному каналу связи (шине). Проще реализовать (сконструировать), гибкость модификации программ.
    \item \textbf{Гарвардская архитектура:} предусматривает раздельные хранилища и потоки передачи (шины) для команд и данных. Возможность одновременной работы с данными и командами.
\end{itemize}

В более подробное описание, определяющее конкретную архитектуру, также входят: структурная схема ЭВМ, средства и способы доступа к элементам этой структурной схемы, организация и разрядность интерфейсов ЭВМ, набор и доступность регистров, организация памяти и способы её адресации, набор и формат машинных команд процессора, способы представления и форматы данных, правила обработки прерываний.

\bigskip
По перечисленным признакам и их сочетаниям среди архитектур выделяют:
\begin{enumerate}
    \item \textbf{По разрядности интерфейсов и машинных слов}: 8-, 16-, 32-, 64-, 128-разрядные.
    \item \textbf{По особенностям набора команд и регистров}:
          \begin{itemize}
              \item CISC --- Complete Instruction Set Computer
              \item RISC --- Restricted (Reduced) Instruction Set Computer
              \item CRISP --- Complex-Reduced-Instruction-Set Processor
              \item VLIW --- Very Long Instruction Word
          \end{itemize}
    \item \textbf{По количеству вычислителей}: однопроцессорные, многопроцессорные, одноядерные, многоядерные.
    \item \textbf{Многопроцессорные по принципу взаимодействия с памятью}: симметричные многопроцессорные (SMP), масcивно-параллельные (MPP), распределенные.
\end{enumerate}

Существуют следующие архитектуры систем команд (рисунок \ref{fig:classification}):
\begin{itemize}
    \item \textbf{Регистровая архитектура} --- внутри процессора существует специальная память (регистры) для хранения промежуточных результатов.
    \item \textbf{Аккумуляторная архитектура} --- существует один регистр (аккумулятор), в котором хранится результат.
    \item \textbf{Стековая архитектура (MISC --- Minimal Instruction Set Computer)} --- команды не имеют операндов.
\end{itemize}

Типичные операции (сложение и умножение) требуют от любого вычислительного устройства нескольких действий: выборку двух операндов, выбор инструкции и её выполнение, и, наконец, сохранение результата.
Идея, предложенная и  реализованная Эйкеном, заключалась в физическом разделении линий передачи команд и данных.
В первом компьютере Эйкена «Марк I» для хранения инструкций использовалась перфорированная лента, а для работы с данными --- электромеханические регистры.
Это позволяло одновременно пересылать и обрабатывать команды и данные, благодаря чему значительно повышалось общее быстродействие.

Соответствующая схема реализации доступа к памяти имеет один очевидный недостаток --- высокую стоимость.
При разделении каналов передачи команд и данных накристалле процессора последний должен иметь почти в два раза больше выводов (так как шины адреса и данных составляют основную часть выводов микропроцессора).
Способом решения этой проблемы стала идея использовать общую шину данных и шину адреса для всех внешних данных, а внутри процессора использовать шину данных, шину команд и две шины адреса.
Такую концепцию стали называть \textbf{\emph{модифицированной Гарвардской архитектурой}}.

Такой подход применяется в современных сигнальных процессорах.
Еще дальше по пути уменьшения стоимости пошли при создании однокристалльных ЭВМ --- \textbf{микроконтроллеров}.
В них одна шина команд и данных применяется и внутри кристалла.

Разделение шин в \emph{модифицированной Гарвардской структуре} осуществляется при помощи раздельных управляющих сигналов: чтения, записи или выбора области памяти.

\bigskip
В процессоре ограниченное количество команд, как и в языках программирования.
И каждую операцию он разбивает на более мелкие и простые микрокоманды.
Архитектуры CISC и RISC определяют количество этих микрокоманд.
Например, есть всего 10 команд, а все остальные операции можно составить из этих команд --- это архитектура RISC.
Или на каждую возможную операцию необходима своя команда --- это будет архитектура CISC.
Рассмотрим подробнее.

\subsection{Архитектура CISC}\label{subsec:cisc-architecture}

\textbf{CISC} --- complex instruction set computer --- компьютер с полным набором команд.

\begin{itemize}[noitemsep]
    \item много команд;
    \item мало регистров общего назначения (памяти для хранения операндов арифметико-логических инструкций, а также адресов или отдельных компонентов адресов ячеек памяти) (до 32);
    \item разнообразие способов адресации (прямая, косвенная);
    \item много форматов команд различной разрядности;
    \item обработка совмещается с обращением к памяти;
    \item плавающая длина команд.
\end{itemize}

Доля сложных дополнительных команд CISC в общем объеме программ не превышает 10--20\%.
Емкость микропрограммной памяти для поддержании сложных команд может увеличиваться на 60\%.

\subsection{Архитектура RISC}\label{subsec:risc-architecture}

\textbf{RISC} --- reduced instruction set computer -- компьютер с сокращенным набором команд.
\begin{itemize}[noitemsep]
    \item мало команд (только наиболее часто используемые);
    \item много регистров общего назначения (РОН) (сотни);
    \item есть только две команды обращения к памяти (все остальные команды могут работать только с РОНами);
    \item мало форматов команд и способов указания адресов операндов;
    \item фиксированная длина команд (упрощает обработку).
\end{itemize}

\subsection{Преимущества RISC над CISC}\label{subsec:risc-advantages-over-cisc}
\begin{enumerate}[noitemsep]
    \item Возможность повышения тактовой частоты и упрощения кристалла с высвобождением площади под кэш.
    \item Снижение энергопотребления процессора за счет уменьшения числа транзисторов.
    \item Доля сложных дополнительных команд CISC в общем объеме программ не превышает 10-20\%, а остальные операции похожи на соответствующие аналоги RISC-архитектуры.
    \item Возможность упреждающего выполнения команд.
\end{enumerate}

\textbf{Результат}: большинство современных процессоров являются либо чистыми RISC, либо ``CISC-поверх-RISC''.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{9.6-classification}
    \caption{Классификация систем команд}\label{fig:classification}
\end{figure}

\subsection{Принципы построения ЭВМ}\label{subsec:evm-construction-principles}
Перечислим и обощим принципы построения ЭВМ в целом, сформулированные так же фон Нейманом:
\begin{itemize}[noitemsep]
    \item наличие единого вычислительного устройства, включающего процессор, средства передачи информации и память;
    \item линейная структура адресации памяти, состоящей из слов фиксированной длины;
    \item двоичная система исчисления;
    \item централизованное последовательное управление, устройство управления выборкой команд из памяти и их выполнением;
    \item хранимая программа;
    \item низкий уровень машинного языка;
    \item наличие команд условной и безусловной передачи управления;
    \item АЛУ с представлением чисел в форме с плавающей точкой и производящее операции над данными;;
    \item регистры, осуществляющие временное хранение данных и состояний процессора.
\end{itemize}

\subsection{Команды процессора}\label{subsec:processor-commands}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{9.8-commands-formats}
    \caption{Форматы команд процессора: а) многоадресная, б) адресная, в) безадресная}
\end{figure}


\subsection{Этапы выполнения команд процессором}\label{subsec:command-execution-stages}
Полный цикл выполнения команды может включать в себя следующие этапы:
\begin{itemize}
    \item Вычисление адреса команды (ВАК) --- счетчик команд указывает на некоторую ячейку, содержащую команду;
    \item Выборка команды (ВК) --- обращение к ячейке памяти по адресу, указанному в счетчике команд, считывание команды;
    \item Декодирование команды (ДК) --- процессор распознает, что за команда (сложение, вычитание, переход и так далее);
    \item Вычисление адреса операнда (ВАО) --- если команда адресная, то производится вычисление адреса операнда, который содержит команда;
    \item Выборка операнда (ВО) --- обращение к ячейке памяти по адресу, указанному в команде, считывание операнда;
    \item Выполнение заданной операции (ВЗО);
    \item Запись результата (ЗР).
\end{itemize}

\paragraph{Конвейерная обработка команд}\label{par:pipelining}

При выполнении почти каждой команды, необходимо осуществить 4--7 действий. При выполнении команд последовательно (как это делали старые процессоры) следующая команда будет ждать, пока полностью осуществится первая. Понятно, что можно выполнять команды по принципу конвейера, что существенно увеличит скорость работы.

\begin{figure}[H]
    \centering
    \includegraphics{9.9-risc-pipeline}
    \caption{Пример 5-уровневого конвейера в реальном RISC-процессоре}\label{fig:risc-pipeline}
\end{figure}

\begin{description}[noitemsep]
    \item[IF] --- ВАК+ВК (вычисление адреса команды и выборка команды);
    \item[ID] --- ДК+ВАО+ВО (декодирование команды, вычисление адреса операнда, выборка операнда);
    \item[EX] --- ВЗО (выполнение заданной операции);
    \item[MEM] --- ЗР (запись результата);
    \item[WB] --- ЗР (запись результата);
\end{description}

Видно, что пока первая команда находится на этапе WB, задействован один узел --- записи результата.
Тем временем другой узел --- выполнения заданной операции, может не простаивать, а выполнять третью команду.
И таким образом, все отдельные независящие друг от друга узлы, работают одновременно, выполняя этапы разных команд, чем значительно увеличивают производительность.
