\newline
\subsubsection{Код Хаффмана}
\label{subsubsec:huffman_code}

\begin{wrapfigure}{l}{0.25\textwidth}
    \centering
    \includegraphics[width=0.25\textwidth]{huffman_david}
    \caption*{Дэвид Хаффман\\1925 - 1999}
\end{wrapfigure}

Код (алгоритм) Хаффмана был разработан в 1952 году аспирантом Массачусетского технологического института Дэвидом Хаффманом при написании им курсовой работы.

Как и алгоритм Шеннона-Фано, основан на частоте повторения. Зная вероятности символов в сообщении, можно описать процедуру построения кодов переменной длины, состоящих из целого количества битов. Символам с большей вероятностью ставятся в соответствие более короткие коды. Коды Хаффмана обладают свойством префиксности, что позволяет однозначно их декодировать.

Однако, в отличие от кодов Шеннона-Фано, коды Хаффмана всегда являются оптимальными.

Сжатие данных по Хаффману применяется при сжатии фото- и видеоизображений (JPEG, стандарты сжатия MPEG), в архиваторах (PKZIP, LZH), в протоколах передачи данных MNP5 и MNP7.

\paragraph{Алгоритм Хаффмана для неоптимальных префиксных кодов}

\begin{enumerate}
  \item Символы входного алфавита образуют список свободных узлов. Каждый узел имеет вес, равный вероятности появления символа в сжимаемом тексте (исходной последовательности). Строится дерево от листьев (узлов) к корню:
  \item Выбираются два свободных узла дерева с наименьшими весами;
  \item Создается их родитель с весом, равным их суммарному весу;
  \item Родитель добавляется в список свободных узлов, а двое его детей удаляются из этого списка.
  \item Одной дуге, выходящей из родителя (узлу с большим весом), ставится в соответствие значение $1$, а другой (узлу с меньшим весом) значение $0$.
  \item Повторяем шаги 2-4, выбирая в качестве одного из свободных узлов родителя, до тех пор, пока в списке свободных узлов не останется только один свободный узел. Он и будет считаться корнем дерева.
  \item Символ входного (первичного) алфавита кодируется последовательностью нулей и единиц в соответствии с распределением их от корня дерева к узлам (листьям).
\end{enumerate}

\example{1}

\task