% !TeX root = ../../main.tex
\subsubsection{Оперативная память}\label{subsubsec:ram}
\begin{wrapfigure}[10]{l}{4cm}
    \includegraphics[width=4cm]{src/10_memory/10_11.jpg}
\end{wrapfigure}
В отличие от кэш-памяти, оперативная память устроена намного проще. Она устроена из 1 конденсатора и 1 транзистора, что дешево и занимает мало места. Один конденсатор легче воспринимать как память (конденсатор разряжен - 0, заряжен - 1). Транзистор нужен с одной целью - чтобы не разряжать постоянно конденсатор. Конденсатор необходимо периодически подзаряжать, а заряжается и разряжается он медленно. Переключить транзистор быстрее чем, зарядить или разрядить конденсатор.
\\Если на базу подано напряжение, транзистор открыт, мы можем считать значение - 1. Если напряжения нет, значение не считывается, записывается 0.

\subsection{Локальность памяти}\label{subsec:memory-locality}
\subsubsection{Пространственная локальность памяти}\label{subsubsec:spatial-locality}
С очень высокой вероятностью адрес очередной команды программы либо следует непосредственно за адресом, по которому была считана текущая команда, либо расположен вблизи него. Такое расположение адресов называется \textbf{пространственной локальностью программы}.
\\Обрабатываемые данные, как правило, структурированы, и такие структуры обычно хранятся в последовательных ячейках памяти. Такая особенность программ называется \textbf{пространственной локальностью данных}.

\subsubsection{Временн\'{а}я локальность памяти}\label{subsubsec:temporal-locality}
Кроме того, программы содержат множество небольших циклов и подпрограмм. Это означает, что небольшие наборы команд могут многократно
повторяться в течение некоторого интервала времени, то есть имеет место \textbf{временная локальность}.
\\Все три вида локальности объединяет понятие \textbf{локальность по обращению}. Принцип локальности часто облекают в численную форму и представляют в виде так называемого правила \enquote{90/10}: 90\%
времени работы программы связано с доступом к 10\%
адресного пространства этой программы.
\subsubsection{Применение локальности памяти}\label{subsubsec:memory-locality-application}

Рассмотренные принципы локальности не являются просто любопытным наблюдением. Их использовуют для устранения проблемы узкого места архитектур фон Неймана — шины взаимодействия между процессором и памятью.
\\
\\ Память, как правило, работает на меньшей частоте и с меньшей скоростью чем процессор, но программа достаточно часто обращается к памяти. Это приводит к тому, что скорость работы программы и скорость работы компьютера определяется не скоростью работы процессора, а скоростью работы медленной оперативной памяти.
\\Чтобы устранить эту проблему обычно используют кэш, и эффект от него достаточно ощутим: сильный выигрыш в производительности.
Но почему же тогда вместо медленной оперативной памяти не использовать быструю кэш-память? Рассмотрим пример.
\\
\\Так как мы хотим полностью заменить оперативную памать на кэш, то стоимость компьютера увеличится в сто или даже в тысячу раз (оперативной памяти обычно устанавливают гигабайты, а кэш-память измеряется всего лишь мегабайтами).
\\Чтобы посчитать к какому эффекту это приведёт, будем использовать принцип Парето (\emph{`20\% усилий дают 80\% результата, а остальные 80\% усилий — лишь 20\% результата`}), в соответствии с которым, из-за локальности обращений, 80\% таких обращений попадают в кэш. То есть, при первом обращении большой объем данных приходится копировать из оперативной памяти, что достаточно медленно. Зато далее, в процессе работы программы, с очень высокой вероятностью (в нашем случае – 80\%) при записи/чтении очередной порции данных из памяти мы можем взять её в готовом виде из кэш-памяти. Будем считать, что кэш-память работает в 10 раз быстрее оперативной памяти.
\\Посчитаем, сколько времени понадобится, чтобы выполнить N операций записи или чтения.
\\Оказывается, что в компьютере, где используется медленная оперативная память, то есть до гипотетической модернизации, время выполнения программы будет равно 2,8N (условно измеряемое в наносекундах).
После замены оперативной памяти на кэш-память, все обращения будут происходить со скоростью кэша, следовательно, общее время сократится до N.
\\
\\
Увидев эти цифры можно сделать любопытный вывод. Мы потратили деньги для того, чтобы ускорить работу памяти в 10 раз, но при этом 10-кратное ускорение памяти привело лишь к трехкратному увеличению производительности.
В этом и состоит эффект кэширования: вовсе не обязательно устанавливать в компьютере дорогостоящую быструю память, можно обойтись несколькими уровнями кэша, каждый из которых чуть быстрее (а желательно – на порядок быстрее) предыдущего. Это позволит очень эффективно бороться с узким местом принстонской архитектуры.
